<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/",
                    "three/addons/postprocessing/EffectComposer.js": "https://unpkg.com/three@0.170.0/examples/jsm/postprocessing/EffectComposer.js",
                    "three/addons/postprocessing/ShaderPass.js": "https://unpkg.com/three@0.170.0/examples/jsm/postprocessing/ShaderPass.js",
                    "three/addons/postprocessing/RenderPass.js": "https://unpkg.com/three@0.170.0/examples/jsm/postprocessing/RenderPass.js",
                    "three/addons/postprocessing/UnrealBloomPass.js": "https://unpkg.com/three@0.170.0/examples/jsm/postprocessing/UnrealBloomPass.js",
                    "three/addons/postprocessing/FilmPass.js": "https://unpkg.com/three@0.157.0/examples/jsm/postprocessing/FilmPass.js",
                    "three/addons/shaders/VignetteShader.js": "https://unpkg.com/three@0.157.0/examples/jsm/shaders/VignetteShader.js",
                    "@lumaai/luma-web": "https://unpkg.com/@lumaai/luma-web@0.2.0/dist/library/luma-web.module.js",
                    "dat.gui": "https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js"
                }
            }
        </script>
        <script type="module">
            import {
                WebGLRenderer,
                PerspectiveCamera,
                Scene,
                SphereGeometry,
                Mesh,
                MeshBasicMaterial,
                BackSide,
                DoubleSide,
                FrontSide,
                Color,
                FogExp2,
                Fog,
                AudioListener,
                AudioLoader,
                Audio,
                GridHelper,
                AxesHelper,
                EquirectangularReflectionMapping,
                PMREMGenerator,
                ACESFilmicToneMapping,
                LinearMipmapLinearFilter,
                LinearFilter,
                RepeatWrapping,
                ClampToEdgeWrapping,
                SRGBColorSpace,
                LinearSRGBColorSpace,
                FloatType,
                Vector2,
                TextureLoader,
            } from "three";
            import { VignetteShader } from "three/addons/shaders/VignetteShader.js";
            import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
            import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
            import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
            import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
            import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
            import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
            import { EXRLoader } from "three/addons/loaders/EXRLoader.js";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { GUI } from "dat.gui";
            import { LumaSplatsThree } from "@lumaai/luma-web";

            const panoramaEnhancementShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    gamma: { value: qualityParams.gamma },
                    contrast: { value: qualityParams.contrast },
                    brightness: { value: qualityParams.brightness },
                    saturation: { value: qualityParams.saturation },
                },
                vertexShader: `
                      varying vec2 vUv;
                      void main() {
                          vUv = uv;
                          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                      }
                  `,
                fragmentShader: `
                      uniform sampler2D tDiffuse;
                      uniform float gamma;
                      uniform float contrast;
                      uniform float brightness;
                      uniform float saturation;
                      varying vec2 vUv;

                      vec3 adjustSaturation(vec3 color, float saturation) {
                          float grey = dot(color, vec3(0.2125, 0.7154, 0.0721));
                          return mix(vec3(grey), color, saturation);
                      }

                      vec3 adjustContrast(vec3 color, float contrast) {
                          return (color - 0.5) * contrast + 0.5;
                      }

                      vec3 adjustGamma(vec3 color, float gamma) {
                          return pow(color, vec3(1.0 / gamma));
                      }

                      vec3 adjustBrightness(vec3 color, float brightness) {
                          return color * brightness;
                      }

                      void main() {
                          vec4 texel = texture2D(tDiffuse, vUv);
                          vec3 color = texel.rgb;

                          // Apply adjustments in a physically correct order
                          color = adjustBrightness(color, brightness);    // First adjust brightness
                          color = adjustContrast(color, contrast);        // Then contrast
                          color = adjustSaturation(color, saturation);    // Then saturation
                          color = adjustGamma(color, gamma);              // Finally gamma correction

                          // Ensure colors stay in valid range
                          color = clamp(color, 0.0, 1.0);

                          gl_FragColor = vec4(color, texel.a);
                      }
                  `,
            };

            let composer,
                renderPass,
                panoramaPass,
                bloomPass,
                filmPass,
                vignettePass,
                chromaticAberrationPass;
            // Renderer setup
            let renderer = new WebGLRenderer({
                antialias: false,
                alpha: true,
                transparent: true,
                premultipliedAlpha: true,
                logarithmicDepthBuffer: true,
            });

            function setupPostProcessing() {
                composer = new EffectComposer(renderer);

                // Create all passes
                renderPass = new RenderPass(scene, camera);
                panoramaPass = new ShaderPass(panoramaEnhancementShader);
                const panoramaTrans = new ShaderPass(panoramaTransitionShader);
                bloomPass = new UnrealBloomPass(
                    new Vector2(window.innerWidth, window.innerHeight),
                    postProcessingParams.bloom.strength,
                    postProcessingParams.bloom.radius,
                    postProcessingParams.bloom.threshold,
                );
                filmPass = new FilmPass(
                    postProcessingParams.film.noiseIntensity,
                    postProcessingParams.film.scanlinesIntensity,
                    postProcessingParams.film.scanlinesCount,
                );
                vignettePass = new ShaderPass(VignetteShader);
                chromaticAberrationPass = new ShaderPass(
                    chromaticAberrationShader,
                );

                // Add all passes in order
                composer.addPass(renderPass);
                composer.addPass(panoramaPass);
                composer.addPass(panoramaTrans);
                composer.addPass(bloomPass);
                composer.addPass(filmPass);
                composer.addPass(vignettePass);
                composer.addPass(chromaticAberrationPass);

                // Initialize uniforms AFTER passes are created
                if (panoramaPass && panoramaPass.uniforms) {
                    panoramaPass.uniforms.gamma.value = qualityParams.gamma;
                    panoramaPass.uniforms.contrast.value =
                        qualityParams.contrast;
                    panoramaPass.uniforms.brightness.value =
                        qualityParams.brightness;
                    panoramaPass.uniforms.saturation.value =
                        qualityParams.saturation;
                }

                // Set initial enabled states
                bloomPass.enabled = postProcessingParams.bloom.enabled;
                filmPass.enabled = postProcessingParams.film.enabled;
                vignettePass.enabled = postProcessingParams.vignette.enabled;
                chromaticAberrationPass.enabled =
                    postProcessingParams.chromaticAberration.enabled;

                return {
                    panoramaPass,
                    bloomPass,
                    filmPass,
                    vignettePass,
                    chromaticAberrationPass,
                };
            }

            renderer.setClearColor(new Color(0x333333)); // Add background color to see sphere better
            renderer.domElement.style.position = "absolute";
            renderer.domElement.style.width = "100%";
            renderer.domElement.style.height = "100%";
            renderer.outputColorSpace = SRGBColorSpace;
            renderer.toneMapping = ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.anisotropy = renderer.capabilities.getMaxAnisotropy();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // PMREMGenerator is properly initialized
            const pmremGenerator = new PMREMGenerator(renderer);
            pmremGenerator.compileCubemapShader();
            pmremGenerator.compileEquirectangularShader();
            document.body.appendChild(renderer.domElement);

            const rgbeLoader = new RGBELoader();

            // Audio setup
            //
            let listener = new AudioListener();
            let sound = new Audio(listener);
            let audioLoader = new AudioLoader();
            let convolver = listener.context.createConvolver(); // Using Web Audio API's convolver
            let reverbGain = listener.context.createGain(); // Add this gain node

            // Connect convolver to gain node
            convolver.connect(reverbGain);
            reverbGain.connect(listener.context.destination);

            async function loadSound(soundPath, irPath = null) {
                if (!soundPath) {
                    if (sound.isPlaying) sound.stop();
                    return;
                }

                try {
                    const soundBuffer = await new Promise((resolve, reject) => {
                        audioLoader.load(soundPath, resolve, undefined, reject);
                    });

                    sound.setBuffer(soundBuffer);
                    sound.setLoop(true);
                    sound.setVolume(params.volume);

                    if (irPath) {
                        await loadImpulseResponse(irPath);
                        // Connect through the gain node
                        sound.gain.disconnect();
                        sound.gain.connect(convolver);
                    } else {
                        sound.gain.disconnect();
                        sound.gain.connect(listener.context.destination);
                    }

                    if (params.soundEnabled) {
                        sound.play();
                    }
                } catch (error) {
                    console.error("Error loading audio:", error);
                }
            }

            // Debuggers
            //
            let gridHelper = new GridHelper(10, 10);
            let axesHelper = new AxesHelper(5);

            // Load sound immediately
            //
            audioLoader.load(
                "./audio/murmur.mp3",
                function (buffer) {
                    sound.setBuffer(buffer);
                    sound.setLoop(true);
                    sound.setVolume(0.5);
                    console.log("Sound loaded successfully");
                },
                // Progress callback
                function (xhr) {
                    console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
                },
                // Error callback
                function (error) {
                    console.error("Error loading sound:", error);
                },
            );

            // Camera setup
            //
            let camera = new PerspectiveCamera(90, 1, 0.1, 1000);
            camera.add(listener);
            camera.position.z = 2;
            camera.position.y = -2;
            // camera.lookAt(0, 0, 0);

            // Controls setup
            //
            let controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.01;
            controls.enablePan = false;
            controls.minPolarAngle = Math.PI / 2;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 1;
            controls.maxDistance = 2.5;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.1;
            controls.enableZoom = true;
            controls.zoomDampingFactor = 0.2; // Controls how quickly zoom motion stops
            controls.zoomSpeed = 0.1; // Controls overall zoom smoothness

            // Scene setup
            let scene = new Scene();

            scene.fog = new FogExp2(
                new Color(0xe0e1ff).convertLinearToSRGB(),
                0.3,
            );

            const panoramaTransitionShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    tNextDiffuse: { value: null },
                    progress: { value: 0.0 },
                    gamma: { value: qualityParams.gamma },
                    contrast: { value: qualityParams.contrast },
                    brightness: { value: qualityParams.brightness },
                    saturation: { value: qualityParams.saturation },
                },
                vertexShader: `
                      varying vec2 vUv;
                      void main() {
                          vUv = uv;
                          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                      }
                  `,
                fragmentShader: `
                      uniform sampler2D tDiffuse;
                      uniform sampler2D tNextDiffuse;
                      uniform float progress;
                      uniform float gamma;
                      uniform float contrast;
                      uniform float brightness;
                      uniform float saturation;
                      varying vec2 vUv;

                      vec3 adjustSaturation(vec3 color, float saturation) {
                          float grey = dot(color, vec3(0.2125, 0.7154, 0.0721));
                          return mix(vec3(grey), color, saturation);
                      }

                      vec3 adjustContrast(vec3 color, float contrast) {
                          return (color - 0.5) * contrast + 0.5;
                      }

                      vec3 adjustGamma(vec3 color, float gamma) {
                          return pow(color, vec3(1.0 / gamma));
                      }

                      vec3 adjustBrightness(vec3 color, float brightness) {
                          return color * brightness;
                      }

                      void main() {
                          vec4 currentTexel = texture2D(tDiffuse, vUv);
                          vec4 nextTexel = texture2D(tNextDiffuse, vUv);

                          // Radial wipe transition
                          vec2 center = vec2(0.5, 0.5);
                          float radius = distance(vUv, center);
                          float wipeRadius = progress * 1.5;

                          float mix_factor = smoothstep(wipeRadius - 0.1, wipeRadius + 0.1, radius);
                          vec4 transitionTexel = mix(nextTexel, currentTexel, mix_factor);

                          vec3 color = transitionTexel.rgb;
                          color = adjustBrightness(color, brightness);
                          color = adjustContrast(color, contrast);
                          color = adjustSaturation(color, saturation);
                          color = adjustGamma(color, gamma);

                          gl_FragColor = vec4(color, transitionTexel.a);
                      }
                  `,
            };

            const setQualityBasedOnPerformance = () => {
                const fps = renderer.info.render.fps;
                if (fps < 30) {
                    // Lower quality settings
                    pmremGenerator.maxMipLevel = 4;
                    renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
                } else {
                    // Higher quality settings
                    pmremGenerator.maxMipLevel = 8;
                    renderer.setPixelRatio(window.devicePixelRatio);
                }
            };

            // Create the post-processing chain
            // const composer = new EffectComposer(renderer);
            // const renderPass = new RenderPass(scene, camera);
            // const panoramaPass = new ShaderPass(panoramaEnhancementShader);
            // const panoramaTrans = new ShaderPass(panoramaTransitionShader);

            // composer.addPass(renderPass);
            // composer.addPass(panoramaPass);
            // composer.addPass(panoramaTrans);

            // Initialize the values
            panoramaPass.uniforms.gamma.value = qualityParams.gamma;
            panoramaPass.uniforms.contrast.value = qualityParams.contrast;
            panoramaPass.uniforms.brightness.value = qualityParams.brightness;
            panoramaPass.uniforms.saturation.value = qualityParams.saturation;

            const qualityParams = {
                exposure: 1.0,
                gamma: 2.2,
                saturation: 1.0,
                contrast: 1.0,
                brightness: 1.0,
            };
            // GUI setup
            //
            const gui = new GUI();

            // Initialize GUI folders
            const panoramaFolder = gui.addFolder("Panorama Background");
            const environmentFolder = gui.addFolder("Environment Lighting");
            const qualityFolder = gui.addFolder("Quality Settings");
            const fogFolder = gui.addFolder("Fog Settings");
            const soundFolder = gui.addFolder("Sound Settings");
            const reverbFolder = gui.addFolder("Reverb Settings");
            const orbitFolder = gui.addFolder("Orbit Controls");
            const debugFolder = gui.addFolder("Debug Settings");

            // Presets
            const panoramaPresets = {
                None: null,
                Floating_Islands: "./panoramas/ic-06_001.png",
                Medieval_Knights: "./panoramas/ic-06_002.png",
                Modern_Gallery: "./panoramas/ic-06_003.png",
                Cosmic_Dance: "./panoramas/ic-06_004.png",
                Geometric_Corridor: "./panoramas/ic-06_005.png",
                Golden_Odyssey: "./panoramas/ic-06_006.png",
                Golden_Temple: "./panoramas/ic-06_007.png",
                Futuristic_Metropolis: "./panoramas/ic-06_008.png",
                Red_Study: "./panoramas/ic-06_009.png",
                Winged_Guardians: "./panoramas/ic-06_010.png",
                Ocean_View_Lounge: "./panoramas/ic-06_011.png",
                Robot_Legion: "./panoramas/ic-06_012.png",
                Crimson_Wasteland: "./panoramas/ic-06_013.png",
                Corporate_Atrium: "./panoramas/ic-06_014.png",
                Floating_Sanctuary: "./panoramas/ic-06_015.png",
                Mechanical_Crabs: "./panoramas/ic-06_016.png",
                Celestial_Knights: "./panoramas/ic-06_017.png",
                Angelic_Archway: "./panoramas/ic-06_018.png",
                Golden_Guardians: "./panoramas/ic-06_019.png",
                Night_Courtyard: "./panoramas/ic-06_020.png",
                Lakeside_Living: "./panoramas/ic-06_021.png",
                Crystal_City: "./panoramas/ic-06_022.png",
                Azure_Atrium: "./panoramas/ic-06_023.png",
                Desert_Herd: "./panoramas/ic-06_024.png",
                Gray_Chamber: "./panoramas/ic-06_025.png",
                Exhibition_Dome: "./panoramas/ic-06_026.png",
                Nebula_City: "./panoramas/ic-06_027.png",
                Monochrome_Hall: "./panoramas/ic-06_028.png",
                Pillar_Gallery: "./panoramas/ic-06_029.png",
                Purple_Metropolis: "./panoramas/ic-06_030.png",
                Angelic_Choir: "./panoramas/ic-06_031.png",
                Concrete_Solitude: "./panoramas/ic-06_032.png",
                Twin_Pillars: "./panoramas/ic-06_033.png",
                Industrial_Void: "./panoramas/ic-06_034.png",
                Entertainment_Suite: "./panoramas/ic-06_035.png",
                Balloon_Fantasy: "./panoramas/ic-06_036.png",
                Blue_Crustaceans: "./panoramas/ic-06_037.png",
                Celestial_Orchestra: "./panoramas/ic-06_038.png",
                Azure_Gallery: "./panoramas/ic-06_039.png",
                White_Colonnade: "./panoramas/ic-06_040.png",
                Salt_Mine_Cathedral: "./panoramas/ic-06_041.png",
                Floating_Spheres: "./panoramas/ic-06_042.png",
                Future_Spires: "./panoramas/ic-06_043.png",
                Warehouse_Oculus: "./panoramas/ic-06_044.png",
                Sacred_Passage: "./panoramas/ic-06_045.png",
                Dome_City: "./panoramas/ic-06_046.png",
                Planet_Watcher: "./panoramas/ic-06_047.png",
                Geometric_Temple: "./panoramas/ic-06_048.png",
                Cathedral_Window: "./panoramas/ic-06_049.png",
                Storm_Spheres: "./panoramas/ic-06_050.png",
                Floating_City: "./panoramas/ic-06_051.png",
                Hover_Spheres: "./panoramas/ic-06_052.png",
                Modern_Exhibition: "./panoramas/ic-06_053.png",
                Circular_Void: "./panoramas/ic-06_054.png",
                Industrial_Circle: "./panoramas/ic-06_055.png",
                Fractured_Earth: "./panoramas/ic-06_056.png",
                Desert_Orbs: "./panoramas/ic-06_057.png",
                Tiled_Circle: "./panoramas/ic-06_058.png",
                Geometric_Wonder: "./panoramas/ic-06_059.png",
                Circle_Grid: "./panoramas/ic-06_060.png",
                Coastal_Curve: "./panoramas/ic-06_061.png",
                Sky_Temple: "./panoramas/ic-06_062.png",
                Cosmic_Erosion: "./panoramas/ic-06_063.png",
                Desert_Sanctuary: "./panoramas/ic-06_064.png",
                Infinite_Corridor: "./panoramas/ic-06_065.png",
                Crystal_Chamber: "./panoramas/ic-06_066.png",
                Concrete_Pool: "./panoramas/ic-06_067.png",
                Beach_Spheres: "./panoramas/ic-06_068.png",
                Stone_Arches: "./panoramas/ic-06_069.png",
                Industrial_Skylight: "./panoramas/ic-06_070.png",
                Dark_Corridor: "./panoramas/ic-06_071.png",
                Cube_Gallery: "./panoramas/ic-06_072.png",
                Robo_City: "./panoramas/ic-06_073.png",
                Orbital_Room: "./panoramas/ic-06_074.png",
                Floating_Bubbles: "./panoramas/ic-06_075.png",
                Circular_Windows: "./panoramas/ic-06_076.png",
                Control_Room: "./panoramas/ic-06_077.png",
                Polka_Beach: "./panoramas/ic-06_078.png",
                Aurora_Chamber: "./panoramas/ic-06_079.png",
                Orange_Spheres: "./panoramas/ic-06_080.png",
                Sky_Window: "./panoramas/ic-06_081.png",
                Blue_Machine: "./panoramas/ic-06_082.png",
                Balloon_City: "./panoramas/ic-06_083.png",
                Shadow_Circles: "./panoramas/ic-06_084.png",
                Circle_Lights: "./panoramas/ic-06_085.png",
                Domed_Observatory: "./panoramas/ic-06_086.png",
                // ...generatePanoramaPresets(), // This will generate Panorama_001 through Panorama_086
            };

            const postProcessingParams = {
                enabled: true,
                transition: {
                    enabled: true,
                    duration: 2.0,
                },
                bloom: {
                    enabled: false,
                    strength: 1.5,
                    radius: 0.4,
                    threshold: 0.85,
                },
                vignette: {
                    enabled: false,
                    offset: 0.5,
                    darkness: 0.5,
                },
                film: {
                    enabled: false,
                    noiseIntensity: 0.35,
                    scanlinesIntensity: 0.25,
                    scanlinesCount: 648,
                },
                chromaticAberration: {
                    enabled: false,
                    offset: 0.005,
                },
            };

            const environmentPresets = {
                None: null,
                Adams_Bridge: "./environments/adamsbridge.hdr",
                Grunge_Pop: "./environments/grunge_pop.hdr",
                Comic: "./environments/comic.hdr",
                Neo_Tokyo: "./environments/neo_tokyo.hdr",
                Neo_Tokyo_V2: "./environments/neo_tokyo-v2.hdr",
                Studio: "./environments/softbox.hdr",
                Misty: "./environments/kloofendal_28d_misty_puresky_4k.hdr",
                Sunset_03: "./environments/T_HDR360_Pointe_Sunset_03.hdr",
                Sunset_08: "./environments/T_HDR360_Pointe_Sunset_08.hdr",
                Qwantani_Dusk: "./environments/qwantani_dusk_2_2k.exr",
                Clear_Night: "./environments/rogland_clear_night_2k.exr",
                Moonlit_Night: "./environments/rogland_moonlit_night_2k.exr",
                Klippad_Dawn_01: "./environments/klippad_dawn_1_2k.exr",
                Goegap: "./environments/goegap_road_2k.exr",
                Autumn_Field: "./environments/autumn_field_puresky_2k.hdr",
                Basic: "./environments/basic.hdr",
                Blaubeuren_Night: "./environments/blaubeuren_night_2k.hdr",
                Cannon: "./environments/cannon_2k.hdr",
                Creepy_Bathroom: "./environments/creepy_bathroom_2k.hdr",
                Kloofendal_Partly_Cloudy:
                    "./environments/kloofendal_48d_partly_cloudy_puresky_2k.hdr",
                Kloppenheim: "./environments/kloppenheim_02_puresky_2k.hdr",
                Misty_Farm_Road: "./environments/misty_farm_road_2k.hdr",
                Moonless_Golf: "./environments/moonless_golf_2k.hdr",
                Mud_Road: "./environments/mud_road_puresky_2k.hdr",
                Night_Bridge: "./environments/night_bridge_2k.hdr",
                Overcast_Soil_1:
                    "./environments/overcast_soil_puresky_2k (1).hdr",
                Overcast_Soil_2:
                    "./environments/overcast_soil_puresky_2k (2).hdr",
                Overcast_Soil: "./environments/overcast_soil_puresky_2k.hdr",
                Preller_Drive: "./environments/preller_drive_2k.hdr",
                Satara_Night: "./environments/satara_night_no_lamps_2k.hdr",
                Shanghai_Bund: "./environments/shanghai_bund_2k.hdr",
            };

            const fogPresets = {
                None: null,
                Soft_Blue: "#e0e1ff",
                Morning_Mist: "#d4e1ff",
                Warm_Dawn: "#fff1e6",
                Forest_Haze: "#e6ffe6",
                Twilight_Purple: "#f0e6ff",
                Deep_Blue: "#2c3e50",
                Dark_Teal: "#2d545e",
                Dark_Atmosphere: "#1a1a1a",
                Midnight_Blue: "#34495e",
                Sunset_Orange: "#ff9966",
                Dramatic_Red: "#ff6b6b",
                Bright_Teal: "#4ecdc4",
                Rich_Purple: "#9b59b6",
                Full_Moon: "#C4C9D6",
                Blue_Moon: "#A5B5D9",
                Blood_Moon: "#8B0000",
                Golden_Hour: "#FFA500",
                Magic_Hour: "#4B0082",
                Dawn: "#FF7F50",
                Dusk: "#483D8B",
                Misty_Mountains: "#E6E6FA",
                Desert_Heat: "#FFD700",
                Arctic_Chill: "#F0FFFF",
                Storm_Coming: "#4A4A4A",
                Ethereal: "#DDA0DD",
            };

            const soundPresets = {
                None: null,
                Basement: "./audio/ir-basement.wav",
                Murmur: "./audio/murmur.mp3",
                Forest: "./audio/ir-forest.wav",
                Church: "./audio/ir-church.wav",
                Room: "./audio/ir-room.wav",
                Lucid_Dream: "./audio/Lucid_Space-Joseph_Beg.mp3",
                Hypnotic_Dream: "./audio/Hypnotic-beat.wav",
                Bon13_Maedo: "./audio/Bon13-Maedo Meada.mp3",
            };

            const reverbPresets = {
                None: null,
                Basement: "./audio/ir-basement.wav",
                Forest: "./audio/ir-forest.wav",
                Church: "./audio/ir-church.wav",
                Room: "./audio/ir-room.wav",
            };

            const qualityPresets = {
                Default: {
                    gamma: 2.2,
                    contrast: 1.0,
                    brightness: 1.0,
                    saturation: 1.0,
                },
                High_Contrast: {
                    gamma: 2.4,
                    contrast: 1.4,
                    brightness: 1.1,
                    saturation: 1.2,
                },
                Soft_Look: {
                    gamma: 2.0,
                    contrast: 0.8,
                    brightness: 1.1,
                    saturation: 0.9,
                },
                Vivid_Look: {
                    gamma: 2.2,
                    contrast: 1.2,
                    brightness: 1.2,
                    saturation: 1.4,
                },
            };

            const transitionState = {
                isTransitioning: false,
                currentTexture: null,
                nextTexture: null,
                progress: 0,
                duration: 5, // transition duration in seconds
            };

            let passes = setupPostProcessing();
            setupPostProcessingGUI();

            // Holds the current fog color
            const params = {
                // Visual settings
                panoramaPreset: "None",
                environmentPreset: "None",
                fogPreset: "None",

                // Environment params
                envMapIntensity: 1.0,
                environmentRotation: 0,
                exposure: 1.0,

                environmentPreset: "None",
                backgroundPreset: "None",
                useEnvironmentAsBackground: false,
                backgroundIntensity: 1.0, // Add this line
                envMapIntensity: 1.0,

                // Fog params
                fogDensity: 0.12,
                fogColor: "#d4e1ff",

                // Debug params
                showGrid: false,
                showAxes: false,

                // Orbit params
                enableDamping: controls.enableDamping,
                enableZoom: controls.enableZoom,
                enableRotate: controls.enableRotate,
                autoRotate: controls.autoRotate,
                enablePan: controls.enablePan,

                // Orbit speed controls
                dampingFactor: controls.dampingFactor,
                autoRotateSpeed: controls.autoRotateSpeed,
                zoomSpeed: controls.zoomSpeed,
                rotateSpeed: controls.rotateSpeed,

                // Orbit distance limits
                minDistance: controls.minDistance,
                maxDistance: controls.maxDistance,

                // Orbit angle limits (in degrees)
                minPolarAngle: controls.minPolarAngle * (180 / Math.PI),
                maxPolarAngle: controls.maxPolarAngle * (180 / Math.PI),
                minAzimuthAngle: controls.minAzimuthAngle * (180 / Math.PI),
                maxAzimuthAngle: controls.maxAzimuthAngle * (180 / Math.PI),

                // Sound params
                soundEnabled: true,
                soundVolume: 0.5,
                soundPreset: "Lucid_Dream",
            };

            // Reverb parameters
            const reverbParams = {
                enabled: false,
                space: "None",
                level: 0.5,
            };

            const envParams = {
                preset: "None",
                intensity: 1.0,
                rotation: 0,
                envMapIntensity: 1.0,
            };

            const chromaticAberrationShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    offset: { value: 0.005 },
                },
                vertexShader: `
                      varying vec2 vUv;
                      void main() {
                          vUv = uv;
                          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                      }
                  `,
                fragmentShader: `
                      uniform sampler2D tDiffuse;
                      uniform float offset;
                      varying vec2 vUv;
                      void main() {
                          vec2 r = vUv + vec2(offset, 0.0);
                          vec2 g = vUv;
                          vec2 b = vUv - vec2(offset, 0.0);

                          float red = texture2D(tDiffuse, r).r;
                          float green = texture2D(tDiffuse, g).g;
                          float blue = texture2D(tDiffuse, b).b;

                          gl_FragColor = vec4(red, green, blue, 1.0);
                      }
                  `,
            };

            // Call setupPostProcessing after scene initialization

            // Then when you're ready to initialize
            passes = setupPostProcessing();

            function setupPostProcessingGUI() {
                const postProcessingFolder = gui.addFolder("Post Processing");

                postProcessingFolder
                    .add(postProcessingParams, "enabled")
                    .name("Enable Effects")
                    .onChange((value) => {
                        composer.enabled = value;
                    });

                // Transition controls
                const transitionFolder =
                    postProcessingFolder.addFolder("Transition Effect");
                transitionFolder
                    .add(postProcessingParams.transition, "enabled")
                    .name("Enable")
                    .onChange((value) => {
                        passes.panoramaPass.enabled = value;
                    });
                transitionFolder
                    .add(postProcessingParams.transition, "duration", 0.1, 5.0)
                    .name("Duration");

                // Bloom controls
                const bloomFolder = postProcessingFolder.addFolder("Bloom");
                bloomFolder
                    .add(postProcessingParams.bloom, "enabled")
                    .name("Enable")
                    .onChange((value) => {
                        passes.bloomPass.enabled = value;
                    });
                bloomFolder
                    .add(postProcessingParams.bloom, "strength", 0, 3)
                    .onChange((value) => {
                        passes.bloomPass.strength = value;
                    });
                bloomFolder
                    .add(postProcessingParams.bloom, "radius", 0, 1)
                    .onChange((value) => {
                        passes.bloomPass.radius = value;
                    });
                bloomFolder
                    .add(postProcessingParams.bloom, "threshold", 0, 1)
                    .onChange((value) => {
                        passes.bloomPass.threshold = value;
                    });
            }

            function loadImpulseResponse(irPath) {
                if (!irPath) {
                    console.warn("No impulse response path provided");
                    return Promise.resolve(null);
                }

                return fetch(irPath)
                    .then((response) => {
                        if (!response.ok) {
                            throw new Error(
                                `HTTP error! status: ${response.status}`,
                            );
                        }
                        return response.arrayBuffer();
                    })
                    .then((arrayBuffer) => {
                        return listener.context.decodeAudioData(arrayBuffer);
                    })
                    .then((audioBuffer) => {
                        convolver.buffer = audioBuffer;
                    })
                    .catch((error) => {
                        console.error("Error loading impulse response:", error);
                        throw error;
                    });
            }

            function loadPanorama(path) {
                return new Promise((resolve, reject) => {
                    const textureLoader = new TextureLoader();
                    textureLoader.load(
                        path,
                        (texture) => {
                            texture.mapping = EquirectangularReflectionMapping;
                            texture.colorSpace = SRGBColorSpace;
                            texture.generateMipmaps = true;
                            texture.minFilter = LinearMipmapLinearFilter;
                            texture.magFilter = LinearFilter;
                            resolve(texture);
                        },
                        (xhr) => {
                            console.log(
                                `${(xhr.loaded / xhr.total) * 100}% loaded`,
                            );
                        },
                        reject,
                    );
                });
            }

            function loadEnvironmentMap(path) {
                return new Promise((resolve, reject) => {
                    if (!path) {
                        resolve(null);
                        return;
                    }

                    const extension = path.split(".").pop().toLowerCase();
                    const loader =
                        extension === "hdr"
                            ? new RGBELoader().setDataType(FloatType)
                            : new EXRLoader().setDataType(FloatType);

                    loader.load(
                        path,
                        (texture) => {
                            texture.mapping = EquirectangularReflectionMapping;

                            // Create environment map for lighting
                            const envMap =
                                pmremGenerator.fromEquirectangular(
                                    texture,
                                ).texture;

                            // Keep original texture for background if needed
                            if (params.useEnvironmentAsBackground) {
                                scene.background = texture;
                            }

                            texture.dispose();
                            pmremGenerator.dispose();

                            resolve(envMap);
                        },
                        undefined,
                        reject,
                    );
                });
            }

            window.addEventListener("resize", onWindowResize, false);

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            }

            // VISUAL CONTROLS

            // Panorama Controls
            panoramaFolder
                .add(params, "backgroundPreset", Object.keys(panoramaPresets))
                .name("Background Image")
                .onChange(async (value) => {
                    try {
                        // If we're using environment as background, don't change anything
                        if (params.useEnvironmentAsBackground) {
                            console.log(
                                "Background controlled by environment map",
                            );
                            return;
                        }

                        if (value === "None") {
                            scene.background = scene.fog.color;
                            return;
                        }

                        const texture = await loadPanorama(
                            panoramaPresets[value],
                        );
                        scene.background = texture;
                    } catch (error) {
                        console.error("Error loading panorama:", error);
                        scene.background = scene.fog.color;
                    }
                });

            panoramaFolder
                .add(params, "backgroundPreset", Object.keys(panoramaPresets))
                .name("Background Image")
                .onChange(async (value) => {
                    if (params.useEnvironmentAsBackground) {
                        console.log("Background controlled by environment map");
                        return;
                    }

                    if (value === "None") {
                        scene.background = scene.fog.color;
                        return;
                    }

                    await loadPanoramaWithTransition(panoramaPresets[value]);
                });

            // Environment Controls
            environmentFolder
                .add(
                    params,
                    "environmentPreset",
                    Object.keys(environmentPresets),
                )
                .name("Preset")
                .onChange(async (value) => {
                    try {
                        if (value === "None") {
                            scene.environment = null;
                            return;
                        }

                        const path = environmentPresets[value];
                        if (!path) {
                            console.warn(`No path found for preset: ${value}`);
                            return;
                        }

                        const envMap = await loadEnvironmentMap(path);
                        if (envMap) {
                            scene.environment = envMap;
                        }
                    } catch (error) {
                        console.error("Error loading environment map:", error);
                        scene.environment = null;
                        // Optionally revert to 'None' in the GUI
                        params.environmentPreset = "None";
                        gui.updateDisplay();
                    }
                });

            environmentFolder
                .add(params, "envMapIntensity", 0, 2)
                .name("Intensity")
                .onChange((value) => {
                    if (scene.environment) {
                        scene.traverse((object) => {
                            if (
                                object.material &&
                                object.material.envMapIntensity !== undefined
                            ) {
                                object.material.envMapIntensity = value;
                                object.material.needsUpdate = true;
                            }
                        });
                    }
                });

            environmentFolder
                .add(params, "environmentRotation", 0, 360)
                .name("Rotation")
                .onChange((value) => {
                    scene.rotation.y = (value * Math.PI) / 180;
                });

            environmentFolder
                .add(params, "exposure", 0, 2)
                .name("Exposure")
                .onChange((value) => {
                    renderer.toneMappingExposure = value;
                });

            environmentFolder
                .add(
                    {
                        testEnvironment: () => {
                            console.log(
                                "Current environment:",
                                scene.environment,
                            );
                            console.log(
                                "Environment intensity:",
                                params.envMapIntensity,
                            );
                            console.log("Tone mapping:", renderer.toneMapping);
                            console.log(
                                "Exposure:",
                                renderer.toneMappingExposure,
                            );
                        },
                    },
                    "testEnvironment",
                )
                .name("Debug Environment");

            environmentFolder
                .add(
                    params,
                    "environmentPreset",
                    Object.keys(environmentPresets),
                )
                .name("Environment Light")
                .onChange(async (value) => {
                    try {
                        if (value === "None") {
                            scene.environment = null;
                            return;
                        }

                        const envMap = await loadEnvironmentMap(
                            environmentPresets[value],
                        );
                        if (envMap) {
                            scene.environment = envMap;
                            if (params.useEnvironmentAsBackground) {
                                scene.background = envMap;
                            }
                        }
                    } catch (error) {
                        console.error("Error loading environment map:", error);
                        scene.environment = null;
                    }
                });

            environmentFolder
                .add(params, "useEnvironmentAsBackground")
                .name("Show Environment")
                .onChange((value) => {
                    if (value && scene.environment) {
                        scene.background = scene.environment;
                    } else {
                        // Revert to panorama or fog color
                        if (params.backgroundPreset !== "None") {
                            loadPanorama(
                                panoramaPresets[params.backgroundPreset],
                            ).then((texture) => {
                                scene.background = texture;
                            });
                        } else {
                            scene.background = scene.fog.color;
                        }
                    }
                });

            environmentFolder
                .add(params, "backgroundIntensity", 0, 2)
                .name("Background Intensity")
                .onChange((value) => {
                    scene.backgroundIntensity = value;
                });

            // Fog Controls
            fogFolder
                .add(params, "fogPreset", Object.keys(fogPresets))
                .name("Preset")
                .onChange((value) => {
                    if (value === "None") return;
                    const newColor = fogPresets[value];
                    params.fogColor = newColor;
                    updateFogColor(newColor);
                    gui.updateDisplay();
                });

            fogFolder
                .addColor(params, "fogColor")
                .name("Color")
                .onChange((value) => {
                    updateFogColor(value);
                });

            fogFolder
                .add(params, "fogDensity", 0, 1, 0.01)
                .name("Density")
                .onChange((value) => {
                    scene.fog.density = value;
                });

            // Quality Controls
            qualityFolder
                .add(qualityParams, "gamma", 1, 4)
                .name("Gamma")
                .onChange((value) => {
                    panoramaPass.uniforms.gamma.value = value;
                });

            qualityFolder
                .add(qualityParams, "contrast", 0, 2)
                .name("Contrast")
                .onChange((value) => {
                    panoramaPass.uniforms.contrast.value = value;
                });

            qualityFolder
                .add(qualityParams, "brightness", 0, 2)
                .name("Brightness")
                .onChange((value) => {
                    panoramaPass.uniforms.brightness.value = value;
                });

            qualityFolder
                .add(qualityParams, "saturation", 0, 2)
                .name("Saturation")
                .onChange((value) => {
                    panoramaPass.uniforms.saturation.value = value;
                });

            qualityFolder
                .add(
                    { preset: "Default" },
                    "preset",
                    Object.keys(qualityPresets),
                )
                .name("Presets")
                .onChange((value) => {
                    const preset = qualityPresets[value];
                    Object.assign(qualityParams, preset);

                    // Update shader uniforms
                    panoramaPass.uniforms.gamma.value = preset.gamma;
                    panoramaPass.uniforms.contrast.value = preset.contrast;
                    panoramaPass.uniforms.brightness.value = preset.brightness;
                    panoramaPass.uniforms.saturation.value = preset.saturation;

                    gui.updateDisplay();
                });

            qualityFolder
                .add(
                    {
                        resetDefaults: function () {
                            const defaultPreset = qualityPresets.Default;
                            Object.assign(qualityParams, defaultPreset);

                            // Update shader uniforms
                            panoramaPass.uniforms.gamma.value =
                                defaultPreset.gamma;
                            panoramaPass.uniforms.contrast.value =
                                defaultPreset.contrast;
                            panoramaPass.uniforms.brightness.value =
                                defaultPreset.brightness;
                            panoramaPass.uniforms.saturation.value =
                                defaultPreset.saturation;

                            gui.updateDisplay();
                        },
                    },
                    "resetDefaults",
                )
                .name("Reset Defaults");

            // TECHNICAL CONTROLS

            // Orbit Controls
            orbitFolder
                .add(params, "enableDamping")
                .name("Enable Damping")
                .onChange((value) => {
                    controls.enableDamping = value;
                });

            orbitFolder
                .add(params, "enableZoom")
                .name("Enable Zoom")
                .onChange((value) => {
                    controls.enableZoom = value;
                });

            orbitFolder
                .add(params, "enableRotate")
                .name("Enable Rotate")
                .onChange((value) => {
                    controls.enableRotate = value;
                });

            orbitFolder
                .add(params, "autoRotate")
                .name("Auto Rotate")
                .onChange((value) => {
                    controls.autoRotate = value;
                });

            orbitFolder
                .add(params, "enablePan")
                .name("Enable Pan")
                .onChange((value) => {
                    controls.enablePan = value;
                });

            // Speed Controls subfolder
            const speedFolder = orbitFolder.addFolder("Speed Settings");

            speedFolder
                .add(params, "dampingFactor", 0.01, 0.5)
                .name("Damping Factor")
                .onChange((value) => {
                    controls.dampingFactor = value;
                });

            speedFolder
                .add(params, "autoRotateSpeed", -10, 10)
                .name("Auto Rotate Speed")
                .onChange((value) => {
                    controls.autoRotateSpeed = value;
                });

            speedFolder
                .add(params, "zoomSpeed", 0.1, 5)
                .name("Zoom Speed")
                .onChange((value) => {
                    controls.zoomSpeed = value;
                });

            speedFolder
                .add(params, "rotateSpeed", 0.1, 5)
                .name("Rotate Speed")
                .onChange((value) => {
                    controls.rotateSpeed = value;
                });

            // Distance Controls subfolder
            const distanceFolder = orbitFolder.addFolder("Distance Limits");

            distanceFolder
                .add(params, "minDistance", 0, 10)
                .name("Min Distance")
                .onChange((value) => {
                    controls.minDistance = value;
                });

            distanceFolder
                .add(params, "maxDistance", 0, 20)
                .name("Max Distance")
                .onChange((value) => {
                    controls.maxDistance = value;
                });

            // Angle Controls subfolder
            const angleFolder = orbitFolder.addFolder("Angle Limits");

            angleFolder
                .add(params, "minPolarAngle", 0, 180)
                .name("Min Polar Angle")
                .onChange((value) => {
                    controls.minPolarAngle = (value * Math.PI) / 180;
                });

            angleFolder
                .add(params, "maxPolarAngle", 0, 180)
                .name("Max Polar Angle")
                .onChange((value) => {
                    controls.maxPolarAngle = (value * Math.PI) / 180;
                });

            angleFolder
                .add(params, "minAzimuthAngle", -180, 180)
                .name("Min Azimuth Angle")
                .onChange((value) => {
                    controls.minAzimuthAngle = (value * Math.PI) / 180;
                });

            angleFolder
                .add(params, "maxAzimuthAngle", -180, 180)
                .name("Max Azimuth Angle")
                .onChange((value) => {
                    controls.maxAzimuthAngle = (value * Math.PI) / 180;
                });

            // Debug Controls
            debugFolder
                .add(params, "showGrid")
                .name("Show Grid")
                .onChange((value) => {
                    gridHelper.visible = value;
                });

            debugFolder
                .add(params, "showAxes")
                .name("Show Axes")
                .onChange((value) => {
                    axesHelper.visible = value;
                });

            // Helper function for fog color updates
            function updateFogColor(colorHex) {
                const color = new Color(colorHex);

                // Apply special effects based on preset
                if (params.fogPreset === "Full_Moon") {
                    color.multiplyScalar(1.1).addScalar(0.05);
                } else if (params.fogPreset === "Storm_Coming") {
                    color.multiplyScalar(0.8);
                }

                scene.fog.color = color.convertLinearToSRGB();
            }

            // Scene initialization helper
            function initializeScene() {
                // Set initial fog color
                updateFogColor(params.fogColor);

                // Initialize controls
                controls.enableDamping = params.enableDamping;
                controls.autoRotate = params.autoRotate;
                controls.autoRotateSpeed = params.autoRotateSpeed;

                // Set initial visibility for helpers
                gridHelper.visible = params.showGrid;
                axesHelper.visible = params.showAxes;
            }

            // Call initialization
            initializeScene();

            //>> Sound controls <<\\

            soundFolder
                .add(params, "soundPreset", Object.keys(soundPresets))
                .name("Sound Preset")
                .onChange(async (value) => {
                    try {
                        await loadSound(soundPresets[value]);
                    } catch (error) {
                        console.error("Error changing sound:", error);
                    }
                });

            soundFolder
                .add(
                    {
                        playSound: () => {
                            if (sound.buffer && !sound.isPlaying) {
                                sound.play();
                            }
                        },
                    },
                    "playSound",
                )
                .name("Play Sound");

            soundFolder
                .add(params, "soundVolume", 0, 1, 0.01)
                .name("Volume")
                .onChange((value) => {
                    if (sound) {
                        sound.setVolume(value);
                    }
                });

            soundFolder
                .add(params, "soundEnabled")
                .name("Enable Sound")
                .onChange((value) => {
                    if (!sound.buffer) return;

                    try {
                        if (value) {
                            sound.play();
                        } else {
                            sound.pause();
                        }
                    } catch (error) {
                        console.warn("Sound playback toggle failed:", error);
                    }
                });

            reverbFolder
                .add(reverbParams, "space", Object.keys(reverbPresets))
                .name("Reverb Space")
                .onChange(async (value) => {
                    try {
                        if (value === "None") {
                            sound.gain.disconnect();
                            sound.gain.connect(listener.context.destination);
                            return;
                        }

                        const irPath = reverbPresets[value];
                        if (!irPath) {
                            console.warn(
                                `No impulse response path found for: ${value}`,
                            );
                            return;
                        }

                        await loadImpulseResponse(irPath);

                        if (reverbParams.enabled && convolver.buffer) {
                            sound.gain.disconnect();
                            sound.gain.connect(convolver);
                            convolver.connect(reverbGain);
                            reverbGain.connect(listener.context.destination);
                        }
                    } catch (error) {
                        console.error("Error setting reverb:", error);
                        // Fallback to no reverb
                        sound.gain.disconnect();
                        sound.gain.connect(listener.context.destination);
                        reverbParams.space = "None";
                        gui.updateDisplay();
                    }
                });

            reverbFolder
                .add(reverbParams, "level", 0, 1, 0.01)
                .name("Reverb Level")
                .onChange((value) => {
                    if (reverbGain) {
                        reverbGain.gain.setValueAtTime(
                            value,
                            listener.context.currentTime,
                        );
                    }
                });

            reverbFolder
                .add(reverbParams, "enabled")
                .name("Enable Reverb")
                .onChange((value) => {
                    try {
                        if (value && convolver.buffer) {
                            sound.gain.disconnect();
                            sound.gain.connect(convolver);
                            convolver.connect(reverbGain);
                            reverbGain.connect(listener.context.destination);
                        } else {
                            sound.gain.disconnect();
                            sound.gain.connect(listener.context.destination);
                        }
                    } catch (error) {
                        console.error("Error toggling reverb:", error);
                        reverbParams.enabled = false;
                        gui.updateDisplay();
                    }
                });

            // Initialize audio context and nodes
            let audioContext;

            function initializeAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext ||
                        window.webkitAudioContext)();
                    convolver = audioContext.createConvolver();
                    reverbGain = audioContext.createGain();
                    reverbGain.gain.value = reverbParams.level;
                }
            }

            initializeAudio();

            // RENDER LOOP AND INITIALIZATION

            // Initialize Luma Splats
            const splats = new LumaSplatsThree({
                source: "https://lumalabs.ai/capture/5be32ec6-b11f-44eb-bbb7-57c5beee0d75",
                particleRevealEnabled: true,
                loadingAnimationEnabled: false,
                settings: {
                    shader: {
                        fog: true,
                    },
                },
            });

            splats.addEventListener("load", () => {
                console.log("Model loaded successfully!");
                if (splats.material) {
                    splats.material.fog = true;
                    splats.material.defines = splats.material.defines || {};
                    splats.material.defines.USE_FOG = "";
                    splats.material.defines.FOG_EXP2 = "";
                    splats.material.needsUpdate = true;
                }
            });

            // Add elements to scene
            scene.add(splats);
            scene.add(gridHelper);
            scene.add(axesHelper);

            // Frame loop
            function frameLoop() {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;

                // Handle resize
                if (canvas.width !== width || canvas.height !== height) {
                    composer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height, false);
                }

                // Update materials if needed
                if (splats.material && splats.material.needsUpdate) {
                    splats.material.needsUpdate = false;
                }

                // Update controls
                controls.update();

                // Render
                composer.render();
            }

            // Start animation loop
            frameLoop();

            // Optional: Set up folder states
            const folderStates = {
                panorama: false,
                environment: true,
                quality: false,
                fog: true,
                sound: false,
                reverb: false,
                orbit: false,
                debug: false,
            };

            // Set initial folder states
            Object.entries(folderStates).forEach(([folder, state]) => {
                if (state) {
                    eval(`${folder}Folder`).open();
                }
            });

            // Clean up function (optional)
            function dispose() {
                composer.dispose();
                splats.dispose();
                scene.traverse((object) => {
                    if (object.material) {
                        object.material.dispose();
                    }
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                });
                renderer.dispose();
            }
        </script>
    </body>
</html>
