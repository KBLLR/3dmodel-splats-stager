<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/",
                    "@lumaai/luma-web": "https://unpkg.com/@lumaai/luma-web@0.2.0/dist/library/luma-web.module.js",
                    "dat.gui": "https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js"
                }
            }
        </script>
        <script type="module">
            import {
                WebGLRenderer,
                PerspectiveCamera,
                Scene,
                SphereGeometry,
                Mesh,
                MeshBasicMaterial,
                BackSide,
                DoubleSide,
                FrontSide,
                Color,
                FogExp2,
                Fog,
                AudioListener,
                AudioLoader,
                Audio,
                GridHelper,
                AxesHelper,
                EquirectangularReflectionMapping,
                PMREMGenerator,
                ACESFilmicToneMapping,
            } from "three";
            import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
            import { OrbitControls } from "three/addons/controls/OrbitControls.js";
            import { GUI } from "dat.gui";
            import { LumaSplatsThree } from "@lumaai/luma-web";

            // Renderer setup
            let renderer = new WebGLRenderer({
                antialias: false,
                alpha: true,
                transparent: true,
                premultipliedAlpha: true,
                logarithmicDepthBuffer: true,
            });

            renderer.setClearColor(new Color(0x333333)); // Add background color to see sphere better
            renderer.domElement.style.position = "absolute";
            renderer.domElement.style.width = "100%";
            renderer.domElement.style.height = "100%";
            renderer.toneMapping = ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputColorSpace = "srgb"; // Use this instead

            document.body.appendChild(renderer.domElement);

            // Audio setup
            //
            let listener = new AudioListener();
            let sound = new Audio(listener);
            let audioLoader = new AudioLoader();
            let convolver = listener.context.createConvolver(); // Using Web Audio API's convolver
            let reverbGain = listener.context.createGain(); // Add this gain node

            // Connect convolver to gain node
            convolver.connect(reverbGain);
            reverbGain.connect(listener.context.destination);

            async function loadSound(soundPath, irPath = null) {
                if (!soundPath) {
                    if (sound.isPlaying) sound.stop();
                    return;
                }

                try {
                    const soundBuffer = await new Promise((resolve, reject) => {
                        audioLoader.load(soundPath, resolve, undefined, reject);
                    });

                    sound.setBuffer(soundBuffer);
                    sound.setLoop(true);
                    sound.setVolume(params.volume);

                    if (irPath) {
                        await loadImpulseResponse(irPath);
                        // Connect through the gain node
                        sound.gain.disconnect();
                        sound.gain.connect(convolver);
                    } else {
                        sound.gain.disconnect();
                        sound.gain.connect(listener.context.destination);
                    }

                    if (params.soundEnabled) {
                        sound.play();
                    }
                } catch (error) {
                    console.error("Error loading audio:", error);
                }
            }

            // Debuggers
            //
            let gridHelper = new GridHelper(10, 10);
            let axesHelper = new AxesHelper(5);

            // Load sound immediately
            //
            audioLoader.load(
                "./audio/murmur.mp3",
                function (buffer) {
                    sound.setBuffer(buffer);
                    sound.setLoop(true);
                    sound.setVolume(0.5);
                    console.log("Sound loaded successfully");
                },
                // Progress callback
                function (xhr) {
                    console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
                },
                // Error callback
                function (error) {
                    console.error("Error loading sound:", error);
                },
            );

            // Camera setup
            //
            let camera = new PerspectiveCamera(80, 1, 0.1, 1000);
            camera.add(listener);
            camera.position.z = 2;
            camera.position.y = 2;
            // camera.lookAt(0, 0, 0);

            // Controls setup
            //
            let controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.02;

            controls.enablePan = false;

            controls.minPolarAngle = Math.PI / 2;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 1;
            controls.maxDistance = 2.2;

            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            controls.enableZoom = true;
            controls.zoomDampingFactor = 0.2; // Controls how quickly zoom motion stops
            controls.zoomSpeed = 0.5; // Controls overall zoom smoothness

            // Scene setup
            let scene = new Scene();

            scene.fog = new FogExp2(
                new Color(0xe0e1ff).convertLinearToSRGB(),
                0.4,
            );

            // scene.fog = new Fog(new Color(0xe0e1ff).convertLinearToSRGB(),1,10);

            // GUI setup
            //
            const gui = new GUI();

            const fogFolder = gui.addFolder("Fog Controls");
            const backgroundFolder = gui.addFolder("Background");
            const orbitFolder = gui.addFolder("Orbit Controls");
            const debugFolder = gui.addFolder("Debug");
            const soundFolder = gui.addFolder("Sound");
            const reverbFolder = gui.addFolder("Reverb");
            const envFolder = gui.addFolder("Environment");

            // Holds the current fog color
            const params = {
                // debug params
                showGrid: true,
                showAxes: true,

                //fogExp2 params
                color: "#d4e1ff",
                density: 0.3,
                presetColors: "Morning mist", // dropdown for presets

                // Fog params
                // fogNear: 1,
                // fogFar: 10,
                // fogColor: "#e0e1ff",

                // Background params
                backgroundPreset: "None",

                //orbit Params
                enableDamping: controls.enableDamping,
                enableZoom: controls.enableZoom,
                enableRotate: controls.enableRotate,
                autoRotate: controls.autoRotate,
                enablePan: controls.enablePan,

                // Speed controls
                dampingFactor: controls.dampingFactor,
                autoRotateSpeed: controls.autoRotateSpeed,
                zoomSpeed: controls.zoomSpeed,
                rotateSpeed: controls.rotateSpeed,

                // Distance limits
                minDistance: controls.minDistance,
                maxDistance: controls.maxDistance,

                // Vertical rotation limits
                minPolarAngle: controls.minPolarAngle * (180 / Math.PI), // Convert to degrees
                maxPolarAngle: controls.maxPolarAngle * (180 / Math.PI), // Convert to degrees

                // Horizontal rotation limits
                minAzimuthAngle: controls.minAzimuthAngle * (180 / Math.PI), // Convert to degrees
                maxAzimuthAngle: controls.maxAzimuthAngle * (180 / Math.PI), // Convert to degrees

                //sound params
                soundEnabled: true,
                volume: 0.5,
                soundPreset: "None",
            };
            const reverbParams = {
                enabled: false,
                space: "None",
                reverbLevel: 0.5,
            };
            const envParams = {
                preset: "None",
                intensity: 1.0,
                rotation: 0,
            };

            // Presets
            const colorPresets = {
                "Soft blue": "#e0e1ff",
                "Morning mist": "#d4e1ff",
                "Warm dawn": "#fff1e6",
                "Forest haze": "#e6ffe6",
                "Twilight purple": "#f0e6ff",
                "Deep blue": "#2c3e50",
                "Dark teal": "#2d545e",
                "Dark atmosphere": "#1a1a1a",
                "Midnight blue": "#34495e",
                "Sunset orange": "#ff9966",
                "Dramatic red": "#ff6b6b",
                "Bright teal": "#4ecdc4",
                "Rich purple": "#9b59b6",
                // Moon effects
                "Full Moon": "#C4C9D6",
                "Blue Moon": "#A5B5D9",
                "Blood Moon": "#8B0000",
                // Time of day
                "Golden Hour": "#FFA500",
                "Magic Hour": "#4B0082",
                Dawn: "#FF7F50",
                Dusk: "#483D8B",
                // Atmospheric
                "Misty Mountains": "#E6E6FA",
                "Desert Heat": "#FFD700",
                "Arctic Chill": "#F0FFFF",
                "Storm Coming": "#4A4A4A",
                Ethereal: "#DDA0DD",
            };
            const backgroundPresets = {
                None: "fog", // Will use fog color
                Adams_Bridge: "./backgrounds/adamsbridge.hdr",
                Grunge_Pop: "./backgrounds/grunge_pop.hdr",
                Comic: "./backgrounds/comic.hdr",
                Neo_Tokyo: "./backgrounds/neo_tokyo.hdr",
                Neo_Tokyov2: "./backgrounds/neo_tokyo-v2.hdr",
                Studio: "./backgrounds/softbox.hdr",
                Misty: "./backgrounds/kloofendal_28d_misty_puresky_4k.hdr",
                Sunset03: "./backgrounds/T_HDR360_Pointe_Sunset_03.hdr",
                Sunset08: "./backgrounds/T_HDR360_Pointe_Sunset_08.hdr",
                // Add your HDRI files here
            };
            const envPresets = {
                None: "fog", // Will use fog color
                Adams_Bridge: "./backgrounds/adamsbridge.hdr",
                Grunge_Pop: "./backgrounds/grunge_pop.hdr",
                Comic: "./backgrounds/comic.hdr",
                Neo_Tokyo: "./backgrounds/neo_tokyo.hdr",
                Neo_Tokyov2: "./backgrounds/neo_tokyo-v2.hdr",
                Studio: "./backgrounds/softbox.hdr",
                Misty: "./backgrounds/kloofendal_28d_misty_puresky_4k.hdr",
                Sunset03: "./backgrounds/T_HDR360_Pointe_Sunset_03.hdr",
                Sunset08: "./backgrounds/T_HDR360_Pointe_Sunset_08.hdr",
                // Add your HDRI files here
            };
            const soundPresets = {
                None: null,
                Basement: "./audio/ir-basement.wav",
                Murmur: "./audio/murmur.mp3",
                Forest: "./audio/ir-forest.wav",
                Church: "./audio/ir-church.wav",
                Room: "./audio/ir-room.wav",
                // Night: "./audio/night.mp3",
                // Rain: "./audio/rain.mp3",
                // Add your sound files here
            };
            // Function to load IR
            function loadImpulseResponse(irPath) {
                return fetch(irPath)
                    .then((response) => response.arrayBuffer())
                    .then((arrayBuffer) => {
                        return listener.context.decodeAudioData(arrayBuffer);
                    })
                    .then((audioBuffer) => {
                        convolver.buffer = audioBuffer;
                    });
            }

            // Setup HDRI loading
            const rgbeLoader = new RGBELoader();
            const pmremGenerator = new PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();

            // Environment controls
            envFolder
                .add(envParams, "preset", Object.keys(envPresets))
                .onChange(async (value) => {
                    if (value === "None") {
                        scene.environment = null;
                        scene.background = scene.fog.color;
                        return;
                    }

                    try {
                        await loadHDRI(envPresets[value]);
                    } catch (error) {
                        console.error("Error loading HDRI:", error);
                        scene.environment = null;
                        scene.background = scene.fog.color;
                    }
                });

            // Background intensity control
            envFolder.add(envParams, "intensity", 0, 2).onChange((value) => {
                scene.backgroundIntensity = value;
            });

            // Environment rotation
            envFolder.add(envParams, "rotation", 0, 360).onChange((value) => {
                if (scene.environment) {
                    scene.rotation.y = value * (Math.PI / 180);
                }
            });

            // Optional: Add exposure control
            const renderParams = {
                exposure: 1.0,
            };

            envFolder.add(renderParams, "exposure", 0, 2).onChange((value) => {
                renderer.toneMappingExposure = value;
            });

            // Add controls to GUI
            fogFolder.addColor(params, "color").onChange((value) => {
                scene.fog.color = new Color(value).convertLinearToSRGB();
            });

            fogFolder.add(params, "density", 0, 1, 0.01).onChange((value) => {
                scene.fog.density = value;
            });

            fogFolder
                .add(params, "presetColors", Object.keys(colorPresets))
                .onChange((value) => {
                    const newColor = colorPresets[value];
                    params.color = newColor;
                    scene.fog.color = new Color(newColor).convertLinearToSRGB();
                    // Update the color picker in GUI
                    gui.updateDisplay();
                });

            //>> HDRI background control <<\\

            backgroundFolder
                .add(params, "backgroundPreset", Object.keys(backgroundPresets))
                .onChange((value) => {
                    if (value === "None") {
                        scene.background = scene.fog.color;
                        return;
                    }

                    const rgbeLoader = new RGBELoader();
                    rgbeLoader.load(backgroundPresets[value], (texture) => {
                        texture.mapping = EquirectangularReflectionMapping;
                        scene.background = texture;
                        scene.environment = texture;
                    });
                });

            //>> Orbit Controls <<\\

            orbitFolder.add(params, "enableDamping").onChange((value) => {
                controls.enableDamping = value;
            });
            orbitFolder.add(params, "enableZoom").onChange((value) => {
                controls.enableZoom = value;
            });
            orbitFolder.add(params, "enableRotate").onChange((value) => {
                controls.enableRotate = value;
            });
            orbitFolder.add(params, "autoRotate").onChange((value) => {
                controls.autoRotate = value;
            });
            orbitFolder.add(params, "enablePan").onChange((value) => {
                controls.enablePan = value;
            });
            // Speed controls
            orbitFolder
                .add(params, "dampingFactor", 0.01, 0.5)
                .onChange((value) => {
                    controls.dampingFactor = value;
                });
            orbitFolder
                .add(params, "autoRotateSpeed", -10, 10)
                .onChange((value) => {
                    controls.autoRotateSpeed = value;
                });
            orbitFolder.add(params, "zoomSpeed", 0.1, 5).onChange((value) => {
                controls.zoomSpeed = value;
            });
            orbitFolder.add(params, "rotateSpeed", 0.1, 5).onChange((value) => {
                controls.rotateSpeed = value;
            });
            // Distance limits
            orbitFolder.add(params, "minDistance", 0, 10).onChange((value) => {
                controls.minDistance = value;
            });
            orbitFolder.add(params, "maxDistance", 0, 20).onChange((value) => {
                controls.maxDistance = value;
            });
            // Angle limits (in degrees for easier understanding)
            orbitFolder
                .add(params, "minPolarAngle", 0, 180)
                .onChange((value) => {
                    controls.minPolarAngle = value * (Math.PI / 180);
                });
            orbitFolder
                .add(params, "maxPolarAngle", 0, 180)
                .onChange((value) => {
                    controls.maxPolarAngle = value * (Math.PI / 180);
                });
            orbitFolder
                .add(params, "minAzimuthAngle", -180, 180)
                .onChange((value) => {
                    controls.minAzimuthAngle = value * (Math.PI / 180);
                });
            orbitFolder
                .add(params, "maxAzimuthAngle", -180, 180)
                .onChange((value) => {
                    controls.maxAzimuthAngle = value * (Math.PI / 180);
                });

            //>> Debugger controls <<\\

            debugFolder
                .add(params, "showGrid")
                .onChange((value) => (gridHelper.visible = value));
            debugFolder
                .add(params, "showAxes")
                .onChange((value) => (axesHelper.visible = value));
            debugFolder
                .add(params, "autoRotate")
                .onChange((value) => (controls.autoRotate = value));

            //>> Sound controls <<\\

            // Sound preset control
            soundFolder
                .add(params, "soundPreset", Object.keys(soundPresets))
                .onChange(async (value) => {
                    try {
                        await loadSound(soundPresets[value]);
                    } catch (e) {
                        console.error("Error changing sound:", e);
                    }
                });

            // Add a manual play button to handle browser autoplay restrictions
            soundFolder
                .add(
                    {
                        playSound: () => {
                            if (sound.buffer && !sound.isPlaying) {
                                sound.play();
                            }
                        },
                    },
                    "playSound",
                )
                .name("Play Sound");

            // Volume control with error handling
            soundFolder.add(params, "volume", 0, 1, 0.1).onChange((value) => {
                if (sound) {
                    sound.setVolume(value);
                }
            });

            // Enable/disable toggle with error handling
            soundFolder.add(params, "soundEnabled").onChange((value) => {
                if (!sound.buffer) return;

                try {
                    if (value) {
                        sound.play();
                    } else {
                        sound.pause();
                    }
                } catch (e) {
                    console.warn("Sound playback toggle failed:", e);
                }
            });

            reverbFolder
                .add(reverbParams, "space", [
                    "None",
                    "Basement",
                    "Forest",
                    "Church",
                    "Room",
                ])
                .onChange(async (value) => {
                    if (value === "None") {
                        sound.gain.disconnect();
                        sound.gain.connect(listener.context.destination);
                        return;
                    }

                    const irPath = soundPresets[value];
                    await loadImpulseResponse(irPath);
                    if (reverbParams.enabled) {
                        sound.gain.disconnect();
                        sound.gain.connect(convolver);
                        convolver.connect(listener.context.destination);
                    }
                });

            reverbFolder
                .add(reverbParams, "reverbLevel", 0, 1, 0.01)
                .onChange((value) => {
                    reverbGain.gain.setValueAtTime(
                        value,
                        listener.context.currentTime,
                    );
                });

            // Updated enable/disable control
            reverbFolder.add(reverbParams, "enabled").onChange((value) => {
                if (value && convolver.buffer) {
                    sound.gain.disconnect();
                    sound.gain.connect(convolver);
                } else {
                    sound.gain.disconnect();
                    sound.gain.connect(listener.context.destination);
                }
            });

            // Function to update fog color with enhanced effects
            function updateFogColor(colorHex) {
                const color = new Color(colorHex);

                // Add subtle color variations based on preset
                if (colorHex === colorPresets["Full Moon"]) {
                    // Add slight blue tint for moon effect
                    color.multiplyScalar(1.1).addScalar(0.05);
                } else if (colorHex === colorPresets["Storm Coming"]) {
                    // Darken and add blue tint for storm effect
                    color.multiplyScalar(0.8);
                }

                scene.fog.color = color.convertLinearToSRGB();
            }

            // Open folders by default
            //
            // fogFolder.open();
            // orbitFolder.open();
            // soundFolder.open();
            // debugFolder.open();

            // SCENE BACKGROUND
            //
            function loadHDRI(path) {
                return new Promise((resolve, reject) => {
                    rgbeLoader.load(
                        path,
                        (texture) => {
                            texture.mapping = EquirectangularReflectionMapping;
                            const envMap =
                                pmremGenerator.fromEquirectangular(
                                    texture,
                                ).texture;

                            // Set scene environment and background
                            scene.environment = envMap;
                            scene.background = envMap;

                            // Optional: adjust scene background intensity
                            scene.backgroundIntensity = 1.0;

                            // Clean up
                            texture.dispose();
                            pmremGenerator.dispose();

                            resolve(envMap);
                        },
                        undefined, // Progress callback
                        reject,
                    );
                });
            }
            scene.background = scene.fog.color; //Dramatic effect if off

            // Then add Luma splats
            let splats = new LumaSplatsThree({
                source: "https://lumalabs.ai/capture/5be32ec6-b11f-44eb-bbb7-57c5beee0d75",
                particleRevealEnabled: true,
                loadingAnimationEnabled: false,
                settings: {
                    shader: {
                        fog: true,
                    },
                },
            });

            splats.addEventListener("load", () => {
                console.log("Model loaded successfully!");
                if (splats.material) {
                    // Ensure fog is enabled on the material
                    splats.material.fog = true;
                    splats.material.defines = splats.material.defines || {};
                    splats.material.defines.USE_FOG = "";
                    splats.material.defines.FOG_EXP2 = "";
                    splats.material.needsUpdate = true;
                }
            });

            scene.add(splats, gridHelper, axesHelper);

            function frameLoop() {
                let canvas = renderer.domElement;
                let width = canvas.clientWidth;
                let height = canvas.clientHeight;

                if (canvas.width !== width || canvas.height !== height) {
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height, false);
                }

                // Add this check
                if (splats.material && splats.material.needsUpdate) {
                    splats.material.needsUpdate = false;
                }

                controls.update();
                renderer.render(scene, camera);
            }

            renderer.setAnimationLoop(frameLoop);
        </script>
    </body>
</html>
